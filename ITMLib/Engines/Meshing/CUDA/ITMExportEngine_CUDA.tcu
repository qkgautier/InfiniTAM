
#include "ITMExportEngine_CUDA.h"

#include "../Shared/ITMExportEngine_Shared.h"
#include "ITMExportEngine_CUDA_Shared.tcu"
#include "../../../../ORUtils/CUDADefines.h"

#include <fstream>
#include <vector>

using namespace ITMLib;


namespace ITMLib
{
	template<class TVoxel, class TIndex>
		bool ITMExportEngine_CUDA<TVoxel, TIndex>::ExportTSDFToPcd_hashIndex(
				ITMScene<TVoxel,ITMVoxelBlockHash>* scene,
				const char *basename)
		{
			if(!scene){ return false; }

			ITMGlobalCache<TVoxel>* cache = scene->globalCache;

			bool hasGlobalCache = (cache != NULL);


			TVoxel* voxelBlocks_global = 0;
			TVoxel* voxelBlocks_local = scene->localVBA.GetVoxelBlocks();

			if(hasGlobalCache){ voxelBlocks_global = cache->GetStoredVoxelBlock(0); }

			ORUtils::MemoryBlock<ITMHashEntry> hashTable(1, MEMORYDEVICE_CPU);
			scene->index.getEntriesCPUCopy(hashTable);
			ITMHashEntry* hash = hashTable.GetData(MEMORYDEVICE_CPU);


			int noEntries = hashTable.dataSize;

			ITMHashSwapState swapStateDefault;
			swapStateDefault.state = 2;
			std::vector<ITMHashSwapState> swapStates(noEntries, swapStateDefault);

			if(hasGlobalCache)
			{
				ORcudaSafeCall(cudaMemcpy(swapStates.data(), cache->GetSwapStates(true), noEntries*sizeof(ITMHashSwapState), cudaMemcpyDeviceToHost));
			}

			const size_t MAX_BLOCKS_TRANSFER_SIZE = 512;

			int noPoints = 0;
			std::vector<int> localPtr;
			std::vector<TVoxel> localVoxels_host;
			for(int i = 0; i < noEntries; i++)
			{
				if(hash[i].ptr >= -1 && swapStates[i].state != 2)
				{
					noPoints += countVoxelsInBlock<TVoxel, TIndex>(voxelBlocks_global, i);
				}
				else if(hash[i].ptr >= 0 && swapStates[i].state == 2)
				{
					localPtr.push_back(hash[i].ptr);
				}

				if(localPtr.size() >= MAX_BLOCKS_TRANSFER_SIZE || (i >= noEntries-1 && !localPtr.empty()))
				{
					localVoxels_host.resize(localPtr.size() * SDF_BLOCK_SIZE3);

					getVoxelsFromPtrList<TVoxel, TIndex>(localPtr.size(), voxelBlocks_local, localPtr.data(), localVoxels_host.data());

					for(size_t j = 0; j < localPtr.size(); j++)
					{
						noPoints += countVoxelsInBlock<TVoxel, TIndex>(localVoxels_host.data(), j);
					}

					localPtr.clear();
				}
			}


			if(noPoints <= 0){ return false; }

			std::string filename = std::string(basename) + ".pcd";

			std::ofstream file(filename.c_str());
			if(!file.is_open()){ return false; }

			file << "VERSION 0.7\n";
			file << "FIELDS x y z " << (TVoxel::hasColorInformation? "rgb": "") << " intensity\n";
			file << "SIZE 4 4 4 " << (TVoxel::hasColorInformation? "4": "") << " 4\n";
			file << "TYPE F F F " << (TVoxel::hasColorInformation? "F": "") << " F\n";
			file << "COUNT 1 1 1 " << (TVoxel::hasColorInformation? "1": "") << " 1\n";
			file << "WIDTH " << noPoints << "\n";
			file << "HEIGHT 1\n";
			file << "VIEWPOINT 0 0 0 1 0 0 0\n";
			file << "POINTS " << noPoints << "\n";
			file << "DATA binary\n";


			std::vector<Vector3s> localPtrPos;
			for(int i = 0; i < noEntries; i++)
			{
				if(hash[i].ptr >= -1 && swapStates[i].state != 2)
				{
					exportVoxelsInBlock<TVoxel, TIndex>(file, voxelBlocks_global, i, hash[i].pos);
				}
				else if(hash[i].ptr >= 0 && swapStates[i].state == 2)
				{
					localPtr.push_back(hash[i].ptr);
					localPtrPos.push_back(hash[i].pos);
				}

				if(localPtr.size() >= MAX_BLOCKS_TRANSFER_SIZE || (i >= noEntries-1 && !localPtr.empty()))
				{
					localVoxels_host.resize(localPtr.size() * SDF_BLOCK_SIZE3);

					getVoxelsFromPtrList<TVoxel, TIndex>(localPtr.size(), voxelBlocks_local, localPtr.data(), localVoxels_host.data());

					for(size_t j = 0; j < localPtr.size(); j++)
					{
						exportVoxelsInBlock<TVoxel, TIndex>(file, localVoxels_host.data(), j, localPtrPos[j]);
					}

					localPtr.clear();
					localPtrPos.clear();
				}
			}

			return true;
		}


	template<class TVoxel, class TIndex>
		bool ITMExportEngine_CUDA<TVoxel, TIndex>::ExportTSDFToPcd(const char *filename)
		{ return false; }


	template <>
		bool ITMExportEngine_CUDA<ITMVoxel_s_rgb, ITMVoxelBlockHash>::ExportTSDFToPcd(const char *filename)
		{
			return ExportTSDFToPcd_hashIndex(scene_, filename);
		}

	template <>
		bool ITMExportEngine_CUDA<ITMVoxel_s, ITMVoxelBlockHash>::ExportTSDFToPcd(const char *filename)
		{
			return ExportTSDFToPcd_hashIndex(scene_, filename);
		}

	template <>
		bool ITMExportEngine_CUDA<ITMVoxel_f, ITMVoxelBlockHash>::ExportTSDFToPcd(const char *filename)
		{
			return ExportTSDFToPcd_hashIndex(scene_, filename);
		}

	template <>
		bool ITMExportEngine_CUDA<ITMVoxel_f_rgb, ITMVoxelBlockHash>::ExportTSDFToPcd(const char *filename)
		{
			return ExportTSDFToPcd_hashIndex(scene_, filename);
		}


} // namespace
