
#include "ITMExportEngine_CUDA.h"

#include "../Shared/ITMExportEngine_Shared.h"
#include "../../../../ORUtils/CUDADefines.h"

#include <fstream>
#include <vector>

using namespace ITMLib;

namespace ITMLib
{
	template<class TVoxel>
		__global__ void getVoxelsFromPtrList_device(int noBlocks, int voxelsPerBlock, const int* blockPtr,
				const TVoxel* voxels_in, TVoxel* voxels_out)
		{
			int targetIdx = threadIdx.x + blockIdx.x * blockDim.x;
			if (targetIdx > noBlocks - 1) return;

			for(int i = 0; i < voxelsPerBlock; i++)
			{
				voxels_out[targetIdx * voxelsPerBlock + i] =
					voxels_in[blockPtr[targetIdx] * voxelsPerBlock + i];
			}
		}
}


namespace ITMLib
{
	template<class TVoxel, class TIndex>
		void ITMExportEngine_CUDA<TVoxel, TIndex>::
		getVoxelsFromPtrList(int noBlocks,
				const TVoxel* voxelBlocks_device,
				int* blockPtr_host,
				TVoxel* voxels_host)
		{
			TVoxel* voxels_device;
			int* blockPtr_device;

			ORcudaSafeCall(cudaMalloc((void**)&voxels_device, noBlocks*SDF_BLOCK_SIZE3*sizeof(TVoxel)));
			ORcudaSafeCall(cudaMalloc((void**)&blockPtr_device, noBlocks*sizeof(int)));

			ORcudaSafeCall(cudaMemcpy(blockPtr_device, blockPtr_host, noBlocks*sizeof(int), cudaMemcpyHostToDevice));

			dim3 cudaBlockSizeAL(256, 1);
			dim3 gridSizeAL((int)ceil((float)noBlocks / (float)cudaBlockSizeAL.x));

			getVoxelsFromPtrList_device<<<gridSizeAL, cudaBlockSizeAL>>>(
					noBlocks, SDF_BLOCK_SIZE3, blockPtr_device,
					voxelBlocks_device, voxels_device);

			ORcudaSafeCall(cudaMemcpy(voxels_host, voxels_device, noBlocks*SDF_BLOCK_SIZE3*sizeof(TVoxel), cudaMemcpyDeviceToHost));

			ORcudaSafeCall(cudaFree(voxels_device));
			ORcudaSafeCall(cudaFree(blockPtr_device));
		}

	template<class TVoxel, class TIndex>
		bool ITMExportEngine_CUDA<TVoxel, TIndex>::ExportTSDFToPcd_hashIndex(
				ITMScene<TVoxel,
				ITMVoxelBlockHash>* scene,
				const char *filename)
		{
			if(!scene){ return false; }

			ITMGlobalCache<TVoxel>* cache = scene->globalCache;

			bool hasGlobalCache = (cache != NULL);


			TVoxel* voxelBlocks_global = 0;
			TVoxel* voxelBlocks_local = scene->localVBA.GetVoxelBlocks();

			if(hasGlobalCache){ voxelBlocks_global = cache->GetStoredVoxelBlock(0); }

			ORUtils::MemoryBlock<ITMHashEntry> hashTable(1, MEMORYDEVICE_CPU);
			scene->index.getEntriesCPUCopy(hashTable);
			ITMHashEntry* hash = hashTable.GetData(MEMORYDEVICE_CPU);


			int noEntries = hashTable.dataSize;

			ITMHashSwapState swapStateDefault;
			swapStateDefault.state = 2;
			std::vector<ITMHashSwapState> swapStates(noEntries, swapStateDefault);

			if(hasGlobalCache)
			{
				ORcudaSafeCall(cudaMemcpy(swapStates.data(), cache->GetSwapStates(true), noEntries*sizeof(ITMHashSwapState), cudaMemcpyDeviceToHost));
			}

			const size_t MAX_BLOCKS_TRANSFER_SIZE = 512;

			int noPoints = 0;
			std::vector<int> localPtr;
			std::vector<TVoxel> localVoxels_host;
			for(int i = 0; i < noEntries; i++)
			{
				if(hash[i].ptr >= -1 && swapStates[i].state != 2)
				{
					noPoints += countVoxelsInBlock<TVoxel, TIndex>(voxelBlocks_global, i);
				}
				else if(hash[i].ptr >= 0 && swapStates[i].state == 2)
				{
					localPtr.push_back(hash[i].ptr);
				}

				if(localPtr.size() >= MAX_BLOCKS_TRANSFER_SIZE || (i >= noEntries-1 && !localPtr.empty()))
				{
					localVoxels_host.resize(localPtr.size() * SDF_BLOCK_SIZE3);

					getVoxelsFromPtrList(localPtr.size(), voxelBlocks_local, localPtr.data(), localVoxels_host.data());

					for(size_t j = 0; j < localPtr.size(); j++)
					{
						noPoints += countVoxelsInBlock<TVoxel, TIndex>(localVoxels_host.data(), j);
					}

					localPtr.clear();
				}
			}


			if(noPoints <= 0){ return false; }

			std::ofstream file(filename);
			if(!file.is_open()){ return false; }

			file << "VERSION 0.7\n";
			file << "FIELDS x y z " << (TVoxel::hasColorInformation? "rgb": "") << " intensity\n";
			file << "SIZE 4 4 4 " << (TVoxel::hasColorInformation? "4": "") << " 4\n";
			file << "TYPE F F F " << (TVoxel::hasColorInformation? "F": "") << " F\n";
			file << "COUNT 1 1 1 " << (TVoxel::hasColorInformation? "1": "") << " 1\n";
			file << "WIDTH " << noPoints << "\n";
			file << "HEIGHT 1\n";
			file << "VIEWPOINT 0 0 0 1 0 0 0\n";
			file << "POINTS " << noPoints << "\n";
			file << "DATA binary\n";


			std::vector<Vector3s> localPtrPos;
			for(int i = 0; i < noEntries; i++)
			{
				if(hash[i].ptr >= -1 && swapStates[i].state != 2)
				{
					exportVoxelsInBlock<TVoxel, TIndex>(file, voxelBlocks_global, i, hash[i].pos);
				}
				else if(hash[i].ptr >= 0 && swapStates[i].state == 2)
				{
					localPtr.push_back(hash[i].ptr);
					localPtrPos.push_back(hash[i].pos);
				}

				if(localPtr.size() >= MAX_BLOCKS_TRANSFER_SIZE || (i >= noEntries-1 && !localPtr.empty()))
				{
					localVoxels_host.resize(localPtr.size() * SDF_BLOCK_SIZE3);

					getVoxelsFromPtrList(localPtr.size(), voxelBlocks_local, localPtr.data(), localVoxels_host.data());

					for(size_t j = 0; j < localPtr.size(); j++)
					{
						exportVoxelsInBlock<TVoxel, TIndex>(file, localVoxels_host.data(), j, localPtrPos[j]);
					}

					localPtr.clear();
					localPtrPos.clear();
				}
			}

			return true;
		}


	template<class TVoxel, class TIndex>
		bool ITMExportEngine_CUDA<TVoxel, TIndex>::ExportTSDFToPcd(const char *filename)
		{ return false; }


	template <>
		bool ITMExportEngine_CUDA<ITMVoxel_s_rgb, ITMVoxelBlockHash>::ExportTSDFToPcd(const char *filename)
		{
			return ExportTSDFToPcd_hashIndex(scene_, filename);
		}

	template <>
		bool ITMExportEngine_CUDA<ITMVoxel_s, ITMVoxelBlockHash>::ExportTSDFToPcd(const char *filename)
		{
			return ExportTSDFToPcd_hashIndex(scene_, filename);
		}

	template <>
		bool ITMExportEngine_CUDA<ITMVoxel_f, ITMVoxelBlockHash>::ExportTSDFToPcd(const char *filename)
		{
			return ExportTSDFToPcd_hashIndex(scene_, filename);
		}

	template <>
		bool ITMExportEngine_CUDA<ITMVoxel_f_rgb, ITMVoxelBlockHash>::ExportTSDFToPcd(const char *filename)
		{
			return ExportTSDFToPcd_hashIndex(scene_, filename);
		}


} // namespace
