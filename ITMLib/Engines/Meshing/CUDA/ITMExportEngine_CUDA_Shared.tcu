
// Created by Quentin Gautier on 2018/5/13

#pragma once


namespace ITMLib
{
	template<class TVoxel>
		__global__ void getVoxelsFromPtrList_device(int noBlocks, int voxelsPerBlock, const int* blockPtr,
				const TVoxel* voxels_in, TVoxel* voxels_out)
		{
			int targetIdx = threadIdx.x + blockIdx.x * blockDim.x;
			if (targetIdx > noBlocks - 1) return;

			for(int i = 0; i < voxelsPerBlock; i++)
			{
				voxels_out[targetIdx * voxelsPerBlock + i] =
					voxels_in[blockPtr[targetIdx] * voxelsPerBlock + i];
			}
		}
}


namespace ITMLib
{
	template<class TVoxel, class TIndex>
		void getVoxelsFromPtrList(int noBlocks,
				const TVoxel* voxelBlocks_device,
				int* blockPtr_host,
				TVoxel* voxels_host)
		{
			TVoxel* voxels_device;
			int* blockPtr_device;

			ORcudaSafeCall(cudaMalloc((void**)&voxels_device, noBlocks*SDF_BLOCK_SIZE3*sizeof(TVoxel)));
			ORcudaSafeCall(cudaMalloc((void**)&blockPtr_device, noBlocks*sizeof(int)));

			ORcudaSafeCall(cudaMemcpy(blockPtr_device, blockPtr_host, noBlocks*sizeof(int), cudaMemcpyHostToDevice));

			dim3 cudaBlockSizeAL(256, 1);
			dim3 gridSizeAL((int)ceil((float)noBlocks / (float)cudaBlockSizeAL.x));

			getVoxelsFromPtrList_device<<<gridSizeAL, cudaBlockSizeAL>>>(
					noBlocks, SDF_BLOCK_SIZE3, blockPtr_device,
					voxelBlocks_device, voxels_device);

			ORcudaSafeCall(cudaMemcpy(voxels_host, voxels_device, noBlocks*SDF_BLOCK_SIZE3*sizeof(TVoxel), cudaMemcpyDeviceToHost));

			ORcudaSafeCall(cudaFree(voxels_device));
			ORcudaSafeCall(cudaFree(blockPtr_device));
		}

} // namespace
